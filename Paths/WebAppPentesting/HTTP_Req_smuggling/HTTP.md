Postoje dvije bitne vrste svercanja HTTP requestova 

CL.TE
Content-length/Tranfer-encoding

Primjer requesta:

-------------------------------
POST /search HTTP/1.1
Host: example.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /update HTTP/1.1
Host: example.com
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

isadmin=true
-------------------------------
Frontend dobiva paket u kojemu ju zapisano da ima duljinu 130 bytova i da je podatak chunked.
Zato sto je chunked, kada backend primiti te pakete, zbog 0, odvojiti ce ih i odvojeno obraditi. Tj prvo ce obraditi prvi i onda drugi.
Zbog toga, generalno ne bi imali pristup /update kada bi ga poslalo na frontend, ali zato sto je frontedn vidio prvi header search, prosljedio ga je backendu i on ga procesirao.



TE.CL
Transfer-Encoding/Content-Length

Primjer requesta:

-------------------------------
POST / HTTP/1.1
Host: example.com
Content-Length: 4
Transfer-Encoding: chunked

78
POST /update HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

isadmin=true
0
-------------------------------

Frontend dobiva ovaj request i nakon chunked vidi 78 koji je hexa, a 120 je decimalan, što znaci da iducih 120 bytova su dio tijela requesta. 
Frontend sve do 0 se smatra dio tijela prvog zahtijev. 
No zbog Content-Length: 4 backend server cita iz requesta samo prva 4 byta koji su: 78\r\n, te ostatak poruke procesira kao odvojenu poruku jer pocinje sa POST /update.
U slucaju da smo greskom stavili contnet-length: 5 on bi procesirao i uzeo P iz POSTA i onda bi iduca "poruka" zapocela sa OST i bila bi automatski odbacena jer je nepravilnog formata.

TE.TE
Transfer-Encoding/Transfer-Encoding

Primjer requesta:

-------------------------------
POST / HTTP/1.1
Host: example.com
Content-length: 4
Transfer-Encoding: chunked
Transfer-Encoding: chunked1

4e
POST /update HTTP/1.1
Host: example.com
Content-length: 15

isadmin=true
0
-------------------------------

Frontend očitava poruku i dolazi do Transfer-Encoding zaglavlja. Frontend možda procesira samo prvo zaglavlje i odbaci drugo jer je nepravilnog oblika, te pritom tumaciti zahtjev sve do 0 ili ce posluzitelj odbaciti kompletno zahtijev.
Backend kada primi dani zahtjev može isto kao frontend za zanemariti ili interpretirati drugacije. kad backend procita samo prva 4 bajta zbog content-lengtha postoji šansa da ostatak zahtijeva  POST /update tretira kao odvojeni i zaseban zahtijev.